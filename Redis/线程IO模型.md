
### 线程 IO 模型
**Redis 是单线程程序！**

- Redis 单线程为什么还能这么快？
> 因为它所有的数据都在内存中，所有的运算都是内存级别的运算。
正因为 Redis 是单线程，所以要小心使用 Redis 指令，
对于那些时间复杂度为 O(n) 级别的指令，一定要谨慎使用，
一不小心就可能会导致 Redis 卡顿。

>Redis是单线程，那为什么还那么快？
因为Redis处理的数据和处理数据的过程都在内存中，内存结构的特点决定了它的高性能特点。
那为什么能处理那么多的高并发客户端连接？
因为它使用了非阻塞IO、多路复用等技术。
瓶颈在网络传输，这瓶颈问题解决了，就能块很多。

#### 非阻塞 IO
>当我们调用套接字的读写方法，默认它们是阻塞的，
比如**read**方法要传递进去一个参数**n**，
表示最多读取这么多字节后再返回，如果一个字节都没有，
那么线程就会卡在那里，直到新的数据到来或者连接关闭了，
**read**方法才可以返回，线程才能继续处理。
而**write**方法一般来说不会阻塞，除非内核为套接字分配的写缓冲区已经满了，
**write**方法就会阻塞，直到缓存区中有空闲空间挪出来了。

>非阻塞 IO 在套接字对象上提供了一个选项**Non_Blocking**，
当这个选项打开时，读写方法不会阻塞，而是能读多少读多少，能写多少写多少。
能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数，
能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数。
读方法和写方法都会通过返回值来告知程序实际读写了多少字节。
 
>有了非阻塞 IO 意味着线程在读写 IO 时可以不必再阻塞了，读写可以瞬间完成然后线程可以继续干别的事了。
 
#### 事件轮询 (多路复用)


#### 指令队列

>Redis 会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。

#### 响应队列

> Redis 同样也会为每个客户端套接字关联一个响应队列。
Redis 服务器通过响应队列来将指令的返回结果回复给客户端。 
如果队列为空，那么意味着连接暂时处于空闲状态，不需要去获取写事件，
也就是可以将当前的客户端描述符从**write_fds**里面移出来。
等到队列有数据了，再将描述符放进去。避免**select**系统调用立即返回写事件，
结果发现没什么数据可以写。出这种情况的线程会飙高 CPU。

#### 定时任务

>服务器处理要响应 IO 事件外，还要处理其它事情。比如定时任务就是非常重要的一件事。如果线程阻塞在 select 系统调用上，定时任务将无法得到准时调度。那 Redis 是如何解决这个问题的呢？
 Redis 的定时任务会记录在一个称为最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的timeout参数。因为 Redis 知道未来timeout时间内，没有其它定时任务需要处理，所以可以安心睡眠timeout的时间。
 
 **Nginx 和 Node 的事件处理原理和 Redis 也是类似的**
